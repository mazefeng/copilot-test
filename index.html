<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿è¿çœ‹æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            touch-action: manipulation;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1/1;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .game-board {
            display: grid;
            width: 100%;
            height: 100%;
        }
        
        .tile {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #4CAF50;
            color: white;
            font-size: 24px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .tile.selected {
            background-color: #FFC107;
            transform: scale(0.95);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        
        .tile.hidden {
            visibility: hidden;
        }
        
        .tile.matched {
            background-color: #8BC34A;
        }
        
        .path {
            position: absolute;
            background-color: rgba(255, 255, 0, 0.5);
            z-index: 10;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        @media (max-width: 500px) {
            .tile {
                font-size: 18px;
            }
            
            .game-info {
                font-size: 16px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <h1>è¿è¿çœ‹æ¸¸æˆ</h1>
    <div class="game-info">
        <div>æ—¶é—´: <span id="time">0</span>ç§’</div>
        <div>å‰©ä½™: <span id="remaining">0</span>å¯¹</div>
    </div>
    <div class="game-container">
        <div class="game-board" id="gameBoard"></div>
    </div>
    <div class="controls">
        <button id="newGameBtn">æ–°æ¸¸æˆ</button>
        <button id="hintBtn">æç¤º</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // æ¸¸æˆé…ç½®
            const config = {
                rows: 8,
                cols: 10,
                tileTypes: 20, // ä¸åŒå›¾æ ‡çš„ç§ç±»æ•°é‡
                gameTime: 300 // æ¸¸æˆæ—¶é—´(ç§’)
            };
            
            // æ¸¸æˆçŠ¶æ€
            let gameState = {
                board: [],
                selectedTile: null,
                matchedPairs: 0,
                totalPairs: 0,
                timeLeft: config.gameTime,
                timer: null,
                isPlaying: false,
                icons: []
            };
            
            // DOMå…ƒç´ 
            const gameBoard = document.getElementById('gameBoard');
            const timeDisplay = document.getElementById('time');
            const remainingDisplay = document.getElementById('remaining');
            const newGameBtn = document.getElementById('newGameBtn');
            const hintBtn = document.getElementById('hintBtn');
            
            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame() {
                // æ¸…é™¤ä¹‹å‰çš„æ¸¸æˆçŠ¶æ€
                clearInterval(gameState.timer);
                gameBoard.innerHTML = '';
                
                // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
                gameState.board = [];
                gameState.selectedTile = null;
                gameState.matchedPairs = 0;
                gameState.timeLeft = config.gameTime;
                gameState.isPlaying = true;
                
                // è®¡ç®—æ€»å¯¹æ•°
                gameState.totalPairs = Math.floor((config.rows * config.cols) / 2);
                remainingDisplay.textContent = gameState.totalPairs;
                timeDisplay.textContent = gameState.timeLeft;
                
                // è®¾ç½®æ¸¸æˆæ¿ç½‘æ ¼
                gameBoard.style.gridTemplateColumns = `repeat(${config.cols}, 1fr)`;
                gameBoard.style.gridTemplateRows = `repeat(${config.rows}, 1fr)`;
                
                // ç”Ÿæˆå›¾æ ‡
                generateIcons();
                
                // åˆ›å»ºæ¸¸æˆæ¿
                createBoard();
                
                // å¼€å§‹è®¡æ—¶å™¨
                gameState.timer = setInterval(updateTimer, 1000);
            }
            
            // ç”Ÿæˆå›¾æ ‡å¯¹
            function generateIcons() {
                gameState.icons = [];
                const pairsNeeded = gameState.totalPairs;
                
                // ä½¿ç”¨emojiä½œä¸ºå›¾æ ‡
                const emojis = ['ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ¯', 
                               'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ¸', 'ğŸµ', 'ğŸ”', 'ğŸ§', 'ğŸ¦', 'ğŸ¤', 'ğŸ¦„'];
                
                // éšæœºé€‰æ‹©éœ€è¦çš„å›¾æ ‡
                const selectedEmojis = [];
                for (let i = 0; i < pairsNeeded; i++) {
                    const emoji = emojis[i % emojis.length];
                    selectedEmojis.push(emoji, emoji); // æ¯å¯¹ä¸¤ä¸ªç›¸åŒçš„
                }
                
                // éšæœºæ’åº
                shuffleArray(selectedEmojis);
                gameState.icons = selectedEmojis;
            }
            
            // åˆ›å»ºæ¸¸æˆæ¿
            function createBoard() {
                for (let i = 0; i < config.rows; i++) {
                    gameState.board[i] = [];
                    for (let j = 0; j < config.cols; j++) {
                        const index = i * config.cols + j;
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        
                        // å¦‚æœå›¾æ ‡è¶³å¤Ÿï¼Œåˆ™åˆ†é…ï¼Œå¦åˆ™ç•™ç©º
                        if (index < gameState.icons.length) {
                            tile.textContent = gameState.icons[index];
                            tile.dataset.value = gameState.icons[index];
                            tile.dataset.row = i;
                            tile.dataset.col = j;
                            
                            tile.addEventListener('click', handleTileClick);
                            tile.addEventListener('touchstart', handleTileClick, { passive: true });
                        } else {
                            tile.classList.add('hidden');
                        }
                        
                        gameBoard.appendChild(tile);
                        gameState.board[i][j] = {
                            element: tile,
                            value: index < gameState.icons.length ? gameState.icons[index] : null,
                            matched: false
                        };
                    }
                }
            }
            
            // å¤„ç†æ–¹å—ç‚¹å‡»
            function handleTileClick(e) {
                if (!gameState.isPlaying) return;
                
                // é˜²æ­¢è§¦æ‘¸äº‹ä»¶å’Œç‚¹å‡»äº‹ä»¶åŒæ—¶è§¦å‘
                if (e.type === 'touchstart') {
                    e.preventDefault();
                }
                
                const tile = e.currentTarget;
                const row = parseInt(tile.dataset.row);
                const col = parseInt(tile.dataset.col);
                const cell = gameState.board[row][col];
                
                // å¿½ç•¥å·²åŒ¹é…æˆ–éšè—çš„æ–¹å—
                if (cell.matched || cell.value === null) return;
                
                // å¦‚æœå·²ç»é€‰ä¸­äº†ä¸€ä¸ªæ–¹å—
                if (gameState.selectedTile) {
                    const selectedRow = gameState.selectedTile.row;
                    const selectedCol = gameState.selectedTile.col;
                    
                    // å¦‚æœç‚¹å‡»çš„æ˜¯åŒä¸€ä¸ªæ–¹å—ï¼Œå–æ¶ˆé€‰æ‹©
                    if (selectedRow === row && selectedCol === col) {
                        gameState.selectedTile.element.classList.remove('selected');
                        gameState.selectedTile = null;
                        return;
                    }
                    
                    // å¦‚æœå€¼ç›¸åŒï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥è¿æ¥
                    if (cell.value === gameState.selectedTile.value) {
                        const path = findPath(
                            {row: selectedRow, col: selectedCol},
                            {row, col}
                        );
                        
                        if (path) {
                            // æ˜¾ç¤ºè¿æ¥è·¯å¾„
                            showPath(path);
                            
                            // æ ‡è®°ä¸ºå·²åŒ¹é…
                            cell.matched = true;
                            gameState.selectedTile.matched = true;
                            
                            cell.element.classList.add('matched');
                            gameState.selectedTile.element.classList.add('matched');
                            
                            // æ›´æ–°åŒ¹é…å¯¹æ•°
                            gameState.matchedPairs++;
                            remainingDisplay.textContent = gameState.totalPairs - gameState.matchedPairs;
                            
                            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                            if (gameState.matchedPairs === gameState.totalPairs) {
                                endGame(true);
                            }
                        }
                    }
                    
                    // æ— è®ºæ˜¯å¦åŒ¹é…ï¼Œéƒ½å–æ¶ˆé€‰æ‹©
                    gameState.selectedTile.element.classList.remove('selected');
                    gameState.selectedTile = null;
                } else {
                    // é€‰æ‹©å½“å‰æ–¹å—
                    gameState.selectedTile = {
                        element: tile,
                        value: cell.value,
                        row,
                        col
                    };
                    tile.classList.add('selected');
                }
            }
            
            // å¯»æ‰¾è¿æ¥è·¯å¾„ (ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢)
            function findPath(start, end) {
                // å¦‚æœä¸¤ä¸ªæ–¹å—ä½ç½®ç›¸åŒï¼Œç›´æ¥è¿”å›
                if (start.row === end.row && start.col === end.col) {
                    return null;
                }
                
                // æ£€æŸ¥ç›´æ¥è¿æ¥ (0æŠ˜)
                if (canConnect(start, end, [])) {
                    return [start, end];
                }
                
                // æ£€æŸ¥1æŠ˜è¿æ¥
                const corner1 = {row: start.row, col: end.col};
                if (isPositionValid(corner1) && 
                    canConnect(start, corner1, []) && 
                    canConnect(corner1, end, [])) {
                    return [start, corner1, end];
                }
                
                const corner2 = {row: end.row, col: start.col};
                if (isPositionValid(corner2) && 
                    canConnect(start, corner2, []) && 
                    canConnect(corner2, end, [])) {
                    return [start, corner2, end];
                }
                
                // æ£€æŸ¥2æŠ˜è¿æ¥ (éœ€è¦æ›´å¤æ‚çš„æœç´¢)
                // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…æ¸¸æˆä¸­å¯èƒ½éœ€è¦æ›´é«˜æ•ˆçš„ç®—æ³•
                for (let i = 0; i < config.rows; i++) {
                    const cornerA = {row: i, col: start.col};
                    const cornerB = {row: i, col: end.col};
                    
                    if (i !== start.row && i !== end.row &&
                        isPositionValid(cornerA) && isPositionValid(cornerB) &&
                        canConnect(start, cornerA, []) &&
                        canConnect(cornerA, cornerB, []) &&
                        canConnect(cornerB, end, [])) {
                        return [start, cornerA, cornerB, end];
                    }
                }
                
                for (let j = 0; j < config.cols; j++) {
                    const cornerA = {row: start.row, col: j};
                    const cornerB = {row: end.row, col: j};
                    
                    if (j !== start.col && j !== end.col &&
                        isPositionValid(cornerA) && isPositionValid(cornerB) &&
                        canConnect(start, cornerA, []) &&
                        canConnect(cornerA, cornerB, []) &&
                        canConnect(cornerB, end, [])) {
                        return [start, cornerA, cornerB, end];
                    }
                }
                
                return null;
            }
            
            // æ£€æŸ¥ä¸¤ç‚¹æ˜¯å¦å¯ä»¥ç›´çº¿è¿æ¥
            function canConnect(a, b, exclude) {
                // å¦‚æœæ˜¯åŒä¸€ä¸ªç‚¹
                if (a.row === b.row && a.col === b.col) {
                    return true;
                }
                
                // æ°´å¹³è¿æ¥
                if (a.row === b.row) {
                    const start = Math.min(a.col, b.col);
                    const end = Math.max(a.col, b.col);
                    
                    for (let col = start + 1; col < end; col++) {
                        const pos = {row: a.row, col};
                        if (!isPositionEmpty(pos) && !isExcluded(pos, exclude)) {
                            return false;
                        }
                    }
                    return true;
                }
                
                // å‚ç›´è¿æ¥
                if (a.col === b.col) {
                    const start = Math.min(a.row, b.row);
                    const end = Math.max(a.row, b.row);
                    
                    for (let row = start + 1; row < end; row++) {
                        const pos = {row, col: a.col};
                        if (!isPositionEmpty(pos) && !isExcluded(pos, exclude)) {
                            return false;
                        }
                    }
                    return true;
                }
                
                return false;
            }
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦ä¸ºç©º(æ— æ–¹å—æˆ–å·²åŒ¹é…)
            function isPositionEmpty(pos) {
                if (pos.row < 0 || pos.row >= config.rows || pos.col < 0 || pos.col >= config.cols) {
                    return true; // è¶…å‡ºè¾¹ç•Œè§†ä¸ºç©º
                }
                return gameState.board[pos.row][pos.col].value === null || 
                       gameState.board[pos.row][pos.col].matched;
            }
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨æ’é™¤åˆ—è¡¨ä¸­
            function isExcluded(pos, exclude) {
                return exclude.some(p => p.row === pos.row && p.col === pos.col);
            }
            
            // æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ
            function isPositionValid(pos) {
                return pos.row >= 0 && pos.row < config.rows && 
                       pos.col >= 0 && pos.col < config.cols;
            }
            
            // æ˜¾ç¤ºè¿æ¥è·¯å¾„
            function showPath(path) {
                // æ¸…é™¤ä¹‹å‰çš„è·¯å¾„
                const oldPaths = document.querySelectorAll('.path');
                oldPaths.forEach(p => p.remove());
                
                // ç»˜åˆ¶æ–°è·¯å¾„
                for (let i = 0; i < path.length - 1; i++) {
                    const start = path[i];
                    const end = path[i + 1];
                    
                    const pathElement = document.createElement('div');
                    pathElement.className = 'path';
                    
                    // è®¡ç®—è·¯å¾„ä½ç½®å’Œå°ºå¯¸
                    const tileSize = gameBoard.clientWidth / config.cols;
                    const left = Math.min(start.col, end.col) * tileSize;
                    const top = Math.min(start.row, end.row) * tileSize;
                    
                    if (start.row === end.row) {
                        // æ°´å¹³è·¯å¾„
                        pathElement.style.left = `${left + tileSize/2}px`;
                        pathElement.style.top = `${top + tileSize/2 - 2}px`;
                        pathElement.style.width = `${Math.abs(end.col - start.col) * tileSize}px`;
                        pathElement.style.height = '4px';
                    } else {
                        // å‚ç›´è·¯å¾„
                        pathElement.style.left = `${left + tileSize/2 - 2}px`;
                        pathElement.style.top = `${top + tileSize/2}px`;
                        pathElement.style.width = '4px';
                        pathElement.style.height = `${Math.abs(end.row - start.row) * tileSize}px`;
                    }
                    
                    gameBoard.appendChild(pathElement);
                    
                    // 3ç§’åæ·¡å‡ºè·¯å¾„
                    setTimeout(() => {
                        pathElement.style.opacity = '0';
                        setTimeout(() => pathElement.remove(), 300);
                    }, 500);
                }
            }
            
            // æ›´æ–°è®¡æ—¶å™¨
            function updateTimer() {
                if (!gameState.isPlaying) return;
                
                gameState.timeLeft--;
                timeDisplay.textContent = gameState.timeLeft;
                
                if (gameState.timeLeft <= 0) {
                    endGame(false);
                }
            }
            
            // ç»“æŸæ¸¸æˆ
            function endGame(isWin) {
                gameState.isPlaying = false;
                clearInterval(gameState.timer);
                
                if (isWin) {
                    alert(`æ­å–œä½ èµ¢äº†ï¼ç”¨æ—¶ ${config.gameTime - gameState.timeLeft} ç§’`);
                } else {
                    alert('æ—¶é—´åˆ°ï¼æ¸¸æˆç»“æŸ');
                }
            }
            
            // æç¤ºåŠŸèƒ½
            function showHint() {
                if (!gameState.isPlaying) return;
                
                // æŸ¥æ‰¾å¯ä»¥è¿æ¥çš„ä¸€å¯¹
                for (let i1 = 0; i1 < config.rows; i1++) {
                    for (let j1 = 0; j1 < config.cols; j1++) {
                        const cell1 = gameState.board[i1][j1];
                        if (cell1.matched || cell1.value === null) continue;
                        
                        for (let i2 = 0; i2 < config.rows; i2++) {
                            for (let j2 = 0; j2 < config.cols; j2++) {
                                const cell2 = gameState.board[i2][j2];
                                if ((i1 === i2 && j1 === j2) || cell2.matched || cell2.value === null) continue;
                                
                                if (cell1.value === cell2.value) {
                                    const path = findPath(
                                        {row: i1, col: j1},
                                        {row: i2, col: j2}
                                    );
                                    
                                    if (path) {
                                        // é«˜äº®æ˜¾ç¤ºè¿™å¯¹æ–¹å—
                                        cell1.element.classList.add('selected');
                                        cell2.element.classList.add('selected');
                                        
                                        // æ˜¾ç¤ºè¿æ¥è·¯å¾„
                                        showPath(path);
                                        
                                        // 3ç§’åå–æ¶ˆé«˜äº®
                                        setTimeout(() => {
                                            cell1.element.classList.remove('selected');
                                            cell2.element.classList.remove('selected');
                                        }, 2000);
                                        
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
                
                alert('æ²¡æœ‰æ‰¾åˆ°å¯è¿æ¥çš„æ–¹å—å¯¹ï¼');
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šéšæœºæ‰“ä¹±æ•°ç»„
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            // äº‹ä»¶ç›‘å¬
            newGameBtn.addEventListener('click', initGame);
            hintBtn.addEventListener('click', showHint);
            
            // å¼€å§‹æ¸¸æˆ
            initGame();
        });
    </script>
</body>
</html>
